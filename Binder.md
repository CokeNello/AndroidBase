
# Linux IO & MMap

#### 什么是用户模式和内核模式

  在计算机系统中，各种硬件资源是有限的，因此为了保证每一个进程都能安全的执行。处理器设有两种模式：“用户模式”与“内核模式”。一些容易发生安全问题的操作都被限制在只有内核模式下才可以执行，例如I/O操作，修改基址寄存器内容等。


#### 什么是系统调用

  连接用户模式和内核模式的接口称之为系统调用。


#### 系统调用的过程

  应用程序代码运行在用户模式下，当应用程序需要调用内核模式下的指令时，先向操作系统发送调用请求。操作系统收到请求后，执行系统调用接口，使处理器进入内核模式。当处理器处理完系统调用操作后，操作系统会让处理器返回用户模式，继续执行用户代码。


#### 什么是用户态和内核态

  处理器设有两种模式：“用户模式”与“内核模式”，当处理器工作在用户模式下的时候，此时就称为用户态；当处理工作在内核模式下，就称为内核态。


#### 什么是用户空间和内核空间

  进程的虚拟地址空间可分为两部分，内核空间和用户空间。内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中，都是对物理地址的映射。


#### 什么是进程隔离

  操作系统中，进程与进程的用户空间的内存和数据都是不共享的。这样做的目的，是为了避免进程间相互操作数据的现象发生，从而引起各自的安全问题。


#### 用户空间和内核空间怎么交互

  通过系统调用来交互

#### 不同进程的用户空间怎么交互

  通过 IPC

#### 什么是IPC

  IPC是进程间通信InterProcess Communication的缩写


#### Linux上常用的IPC方式

  Linux传统IPC通常的做法是消息发送方将要发送的数据存放在自己用户空间的内存缓存区中，通过系统调用从用户态进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。

  像Linux上的Socket、管道、消息队列，都是基于此模型，但是这种方式有很大的缺陷，性能不高，对于数据，需要拷贝两次。

  ![](https://secure2.wostatic.cn/static/srdg6yt84oGxzWCQvSpmDW/image.png?auth_key=1712622318-sKBBXx9FWXSp23Ww6aQE6d-0-d873d504bf41001449a4e031325b3495)

  
#### 什么是MMap

  mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。



#### 什么是 Binder？

  Binder 是Android上特有的跨进程通信方式。


#### 为什么 Android 要采用 Binder 作为 IPC 机制？

  详细回答：[https://www.zhihu.com/question/39440766/answer/89210950](https://www.zhihu.com/question/39440766/answer/89210950)

  出处：[https://juejin.cn/post/6844903589635162126](https://juejin.cn/post/6844903589635162126)

  - 主要是基于性能、稳定性和安全性3方面的原因。
  - 首先从性能上来说，已有的Socket 是一种通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。而消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。
  - 再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制复杂，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。
  - 最后是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。但是传统的 IPC 没有任何安全措施，是由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。Binder机制中，UID/PID 是在内核中添加的。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。而 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。
  - 基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。


#### Binder是怎么加载到Linux内核的

  （跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？）

  Binder通过Linux的动态内核可加载模块（Loadable Kernel Module，LKM）的机制，动态添加Binder模块运行在内核空间


#### 说说 Binder 跨进程通信原理

  Binder IPC 正是基于内存映射（mmap）来实现的。一次完整的 Binder IPC 通信过程通常是这样：

  1. 首先 Binder 驱动在内核空间创建一个数据接收缓存区；
  2. 接着在内核空间开辟一块内核缓存区，建立**内核缓存区**和**内核中数据接收缓存区**之间的映射关系，以及**内核中数据接收缓存区**和**接收进程用户空间地址**的映射关系；
  3. 发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的**内核缓存区**，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。

  ![](https://secure2.wostatic.cn/static/xhvY8HUUEk4ZdPskgc672s/image.png?auth_key=1713186601-s1XdPRXagjyJxF53LUhVir-0-afe052e96bb62b48912a0eba3ee2367e)






